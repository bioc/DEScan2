---
title: "coverage"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading package

```{r}
devtools::load_all()
install.packages("corrplot")
library("corrplot")
```

computing coverages

```{r}

file="inst/extdata/Bed/P43615_Sample_FC1_Input_fwd_chr19_Smartfilter.bed.zip"

chr="chr19"; filetype="bed"; fragmentLength=200;
binSize=50; minWin=50; maxWin=1000; genomeName="mm9";
minCompWinWidth=5000; maxCompWinWidth=10000;
zthresh=5; minCount=0.1; verbose=TRUE; save=FALSE
onlyStdChrs=TRUE
fileGRangesList <- NULL
winVector <- c( (minWin/50):(maxWin/50))


bedGRanges <- constructBedRanges(filename=file, filetype=filetype,
                             genomeName=genomeName,
                             onlyStdChrs=onlyStdChrs)

bedGrangesChrsList <- cutGRangesPerChromosome(bedGRanges)
if(!is.null(chr)) bedGrangesChrsList <- keepRelevantChrs(bedGrangesChrsList, chr)


chrGRanges=bedGrangesChrsList[[1]]

chrBedGRanges=chrGRanges
minWinWidth=minWin
maxWinWidth=maxWin
binWidth=binSize

minWinWidth <- minWinWidth/binWidth
maxWinWidth <- maxWinWidth/binWidth

## dividing chromosome in bins of binWidth dimention each
binnedChromosome <- GenomicRanges::tileGenome(seqlengths=chrBedGRanges@seqinfo,
                                          tilewidth=binWidth,
                                          cut.last.tile.in.chrom=TRUE)
#
st.tm=Sys.time()
olap <- GenomicAlignments::summarizeOverlaps(features=binnedChromosome,
                                         reads=chrBedGRanges,
                                         ignore.strand=TRUE,
                                         inter.feature=FALSE,
                                         mode="IntersectionNotEmpty")
#
# test the coverages with the old coverages using a small amount of reads
chrCovRle1 <- as(SummarizedExperiment::assays(olap)$counts, "Rle")
ed.tm=Sys.time()
message("Summ overl time: ", ed.tm-st.tm)

st.tm=Sys.time()
## computing coverage per single base on bed
chrCoverage <- GenomicRanges::coverage(x=chrBedGRanges)
## computing coverage per each bin on chromosome
chrCovRle <- binnedCovOnly(bins=binnedChromosome,
                       numvar=chrCoverage,
                       mcolname="bin_cov")
ed.tm=Sys.time()
message("binned Cov time: ", ed.tm-st.tm)

message("correlation is: ", cor(as.vector(chrCovRle), as.vector(chrCovRle1)))
```


```{r}
    wins <- minWinWidth:maxWinWidth
    runWinRleList <- IRanges::RleList(
                        lapply(wins, function(win) {
                            message("Running window ", win, " of ", maxWinWidth)
                            evenRunSum(x=chrCovRle, k=win, endrule="constant")
                        })
                     )
    runWinMat=matrix(unlist(runWinRleList), ncol=20, byrow=TRUE)
    print(dim(runWinMat))
```



old coverage con complete grid

```{r}

    file="testData/Bed/chr19/P43615_Sample_FC1_Input_fwd_chr19_Smartfilter.bed.zip"
    chr = 19; filetype = "bed"; fraglen = 200;
    min_win=1;
    rlen = 100; min_bin = 50; max_win = 20; blocksize = 10000;
    zthresh = 5; min_count = 0.1; verbose = FALSE; save = FALSE


        chr <- paste0("chr", chr)
        if (tools::file_ext(file) == "zip") {
            tmp <- unzip(file, list = T)$Name
            file <- unz(file, tmp)
        }
        bed <- utils::read.table(file, sep = "\t", header = FALSE)[, c(1:3, 6)]
        colnames(bed) <- c("seqnames","start","end","strand")
        bed <- bed[bed[,1] == chr,]

    # grid = vector of integers describing the start coordinates for each bin
    grid <- make_grid(bed, fraglen, rlen, min_bin = min_bin)
    ngrid <- length(grid)
    gsize <- grid[2] - grid[1]

    fr <- sort(bed[which(bed[, 4] == "+"), 2]) ## only starts
    rr <- sort(bed[which(bed[, 4] == "-"), 2]) ## only starts

    tot_rds <- length(fr) + length(rr)
    tot_base <- max(rr[length(rr)], fr[length(fr)]) - min(fr[1], rr[1]) ## max start - min start

    # do analysis blockwise due to memory issues
    # fill initial block
    block <- c(1, blocksize + max_win)
    finalblock <- FALSE
    s <- matrix(ncol = 3, nrow = 0, data = 0)
        blocksize_i <- blocksize

        # conditions to stop once as end of grid has been reached

        st.time=Sys.time()
        # cmat = coverage matrix with bins as rows and window sizes as columns
        cmat <- window_coverage_old(Fr = fr, Rr = rr, grid = grid, fraglen = fraglen,
                                    rlen = rlen, max_win = max_win, min_win = min_win,
                                    verbose = FALSE)
        ed.time=Sys.time()
        message("old Cov time: ", ed.tm-st.tm)
        print(dim(cmat))

        print(dim(cmat)[1] - dim(runWinMat)[1])        
        message("cor :", cor(runWinMat[-c(1:60260),], cmat))
        corrplot(cor(runWinMat[-c(1:60260),], cmat))

```













