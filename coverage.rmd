---
title: "coverage"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Loading package

```{r}
devtools::load_all()
install.packages("corrplot")
library("corrplot")
```

computing coverages

```{r}

file="inst/extdata/Bed/P43615_Sample_FC1_Input_fwd_chr19_Smartfilter.bed.zip"

chr="chr19"; filetype="bed"; fragmentLength=200;
binSize=50; minWin=50; maxWin=1000; genomeName="mm9";
minCompWinWidth=5000; maxCompWinWidth=10000;
zthresh=5; minCount=0.1; verbose=TRUE; save=FALSE
onlyStdChrs=TRUE
fileGRangesList <- NULL
winVector <- c( (minWin/50):(maxWin/50))


bedGRanges <- constructBedRanges(filename=file, filetype=filetype,
                             genomeName=genomeName,
                             onlyStdChrs=onlyStdChrs)

bedGrangesChrsList <- cutGRangesPerChromosome(bedGRanges)
if(!is.null(chr)) bedGrangesChrsList <- keepRelevantChrs(bedGrangesChrsList, chr)


chrGRanges=bedGrangesChrsList[[1]]

chrBedGRanges=chrGRanges
minWinWidth=minWin
maxWinWidth=maxWin
binWidth=binSize

minWinWidth <- minWinWidth/binWidth
maxWinWidth <- maxWinWidth/binWidth

## dividing chromosome in bins of binWidth dimention each
binnedChromosome <- GenomicRanges::tileGenome(seqlengths=chrBedGRanges@seqinfo,
                                          tilewidth=binWidth,
                                          cut.last.tile.in.chrom=TRUE)
#
st.tm=Sys.time()
olap <- GenomicAlignments::summarizeOverlaps(features=binnedChromosome,
                                         reads=chrBedGRanges,
                                         ignore.strand=TRUE,
                                         inter.feature=FALSE,
                                         mode="IntersectionNotEmpty")
#
# test the coverages with the old coverages using a small amount of reads
chrCovRle1 <- as(SummarizedExperiment::assays(olap)$counts, "Rle")
ed.tm=Sys.time()
message("Summ overl time: ", ed.tm-st.tm)

wins <- minWinWidth:maxWinWidth
    runWinRleList1 <- IRanges::RleList(
                        lapply(wins, function(win) {
                            message("Running window ", win, " of ", maxWinWidth)
                            floor(evenRunMean(x=chrCovRle, k=win, endrule="constant"))
                        })
                     )
    
st.tm=Sys.time()
## computing coverage per single base on bed
chrCoverage <- GenomicRanges::coverage(x=chrBedGRanges)
## computing coverage per each bin on chromosome
chrCovRle <- binnedCovOnly(bins=binnedChromosome,
                       numvar=chrCoverage,
                       mcolname="bin_cov")
ed.tm=Sys.time()
message("binned Cov time: ", ed.tm-st.tm)

message("correlation is: ", cor(as.vector(chrCovRle), as.vector(chrCovRle1)))


    runWinRleList <- IRanges::RleList(
                        lapply(wins, function(win) {
                            message("Running window ", win, " of ", maxWinWidth)
                            floor(evenRunMean(x=chrCovRle, k=win, endrule="constant"))
                        })
                     )
    
```


```{r}
     wins <- minWinWidth:maxWinWidth
    runWinRleList <- IRanges::RleList(
                        lapply(wins, function(win) {
                            message("Running window ", win, " of ", maxWinWidth)
                            floor(evenRunMean(x=chrCovRle, k=win, endrule="constant"))
                        })
                     )
    runWinRleList
```



old coverage con complete grid

```{r}

    file="testData/Bed/chr19/P43615_Sample_FC1_Input_fwd_chr19_Smartfilter.bed.zip"
    chr = 19; filetype = "bed"; fraglen = 200;
    min_win=1;
    rlen = 100; min_bin = 50; max_win = 20; blocksize = 10000;
    zthresh = 5; min_count = 0.1; verbose = FALSE; save = FALSE


        chr <- paste0("chr", chr)
        if (tools::file_ext(file) == "zip") {
            tmp <- unzip(file, list = T)$Name
            file <- unz(file, tmp)
        }
        bed <- utils::read.table(file, sep = "\t", header = FALSE)[, c(1:3, 6)]
        colnames(bed) <- c("seqnames","start","end","strand")
        bed <- bed[bed[,1] == chr,]

    # grid = vector of integers describing the start coordinates for each bin
    grid <- make_grid(bed, fraglen, rlen, min_bin = min_bin)
    ngrid <- length(grid)
    gsize <- grid[2] - grid[1]

    fr <- sort(bed[which(bed[, 4] == "+"), 2]) ## only starts
    rr <- sort(bed[which(bed[, 4] == "-"), 2]) ## only starts

    tot_rds <- length(fr) + length(rr)
    tot_base <- max(rr[length(rr)], fr[length(fr)]) - min(fr[1], rr[1]) ## max start - min start

    # do analysis blockwise due to memory issues
    # fill initial block
    block <- c(1, blocksize + max_win)
    finalblock <- FALSE
    s <- matrix(ncol = 3, nrow = 0, data = 0)
        blocksize_i <- blocksize

        # conditions to stop once as end of grid has been reached

        st.time=Sys.time()
        # cmat = coverage matrix with bins as rows and window sizes as columns
        cmat <- window_coverage_old(Fr = fr, Rr = rr, grid = grid, fraglen = fraglen,
                                    rlen = rlen, max_win = max_win, min_win = min_win,
                                    verbose = FALSE)
        ed.time=Sys.time()
        message("old Cov time: ", ed.tm-st.tm)
        print(dim(cmat))

        print(dim(cmat)[1] - dim(runWinMat)[1])
        # message("cor :", cor(runWinMat[-c(1:60260),], cmat))
        # corrplot(cor(runWinMat[-c(1:60260),], cmat))

```

```{r}
            # compute coverage using a 5kb window
            headstart <- ceiling(5000 / gsize) * gsize
            # grid05k <- c(seq(grid0[1] - headstart, grid0[1], by = gsize), grid0)
            grid05k <-  grid
            offset5k <- length(grid05k) - length(grid)
            c5k <- window_coverage_old(fr, rr, grid05k, fraglen = fraglen, rlen = rlen,
                                   max_win = 5000, min_win = 5000, verbose = FALSE)
            # compute coverage using a 10kb window
            headstart <- ceiling(10000 / gsize) * gsize
            # grid010k <- c(seq(grid0[1] - headstart, grid0[1], by = gsize), grid0)
            grid010k <- grid
            offset10k <- length(grid010k) - length(grid)
            c10k <- window_coverage_old(fr, rr, grid010k, fraglen = fraglen,
                                    rlen = rlen, max_win = 10000,
                                    min_win = 10000, verbose = FALSE)
            # determine lambda for 5k, 10k windows and baseline
            lamloc <- matrix(nrow = nrow(cmat), ncol = ncol(cmat), data = 0)
            lam5k <- matrix(nrow = nrow(cmat), ncol = ncol(cmat), data = 0)
            lam10k <- matrix(nrow = nrow(cmat), ncol = ncol(cmat), data = 0)
            lambl <- matrix(nrow = nrow(cmat), ncol = ncol(cmat), data = 0)
            for (win in min_win:max_win) {
                # lam5k[, win - min_win + 1] <- c5k[offset5k + c(1:length(grid0)) - floor(win / 2)] * win / 5000
                # lam10k[, win - min_win + 1] <- c10k[offset10k + c(1:length(grid0)) - floor(win / 2)] * win / 10000
                lam5k[, win - min_win + 1] <- c5k[c(1:length(grid))] * win / 5000
                lam10k[, win - min_win + 1] <- c10k[c(1:length(grid))] * win / 10000
                lambl[, win - min_win + 1] <- tot_rds * win / tot_base
            }
            lamloc <- pmax(lam5k, lam10k, lambl)
            # calculate z score for each bin x window combination
            z <- sqrt(2) * sign(cmat - lamloc) *
                sqrt(cmat * log(pmax(cmat, min_count) / lamloc) - (cmat - lamloc))
            length(z[which(z > 100, arr.ind=TRUE)])
            # if(length(which(z>100)) >0 ) print(z[which(z>100, arr.ind=TRUE)])
            # find high z scores keeping one with no intersecting other bin/windows
            # new_ss <- get_disjoint_max_win_old(z0 = z,
            #                               sigwin = fraglen / gsize, nmax = Inf,
            #                               zthresh = zthresh, two_sided = FALSE,
            #                               verbose = FALSE)
            # # convert new_s bins and width into genomic coordinates and append to s
            # new_s=matrix(nrow=nrow(new_ss), ncol=ncol(new_ss))
            # if (nrow(new_ss) >= 1) {
            #     new_s[, 1] <- new_ss[, 1] + block[1] - 1
            #     new_s <- cbind(grid[new_ss[, 1, drop = FALSE]],
            #                    ## when the window is equal to 1 then the end is equal to the start,
            #                    ## but the window should be multiplicated by the binsize
            #                    grid[new_ss[, 1, drop = FALSE] + new_ss[, 2, drop = FALSE] - 1],
            #                    new_ss[, 3, drop = FALSE])
            #     s <- rbind(s, new_s)
            # 

```



```{r}
computeCoverageMovingWindowOnChr <- function(chrBedGRanges, minWinWidth=50,
                                             maxWinWidth=1000, binWidth=50,
                                             verbose=TRUE)
{
    ## converting base notation to bin notation
    minWinWidth <- minWinWidth/binWidth
    maxWinWidth <- maxWinWidth/binWidth

    ## dividing chromosome in bins of binWidth dimention each
    binnedChromosome <- GenomicRanges::tileGenome(seqlengths=chrBedGRanges@seqinfo,
                                                  tilewidth=binWidth,
                                                  cut.last.tile.in.chrom=TRUE)

    # olap <- GenomicAlignments::summarizeOverlaps(features=binnedChromosome,
    #                                              reads=chrBedGRanges,
    #                                              ignore.strand=TRUE,
    #                                              inter.feature=FALSE,
    #                                              mode="IntersectionNotEmpty")
    # #
    # # test the coverages with the old coverages using a small amount of reads
    # chrCovRle1 <- as(SummarizedExperiment::assays(olap)$counts, "Rle")

    ## computing coverage per single base on bed
    chrCoverage <- GenomicRanges::coverage(x=chrBedGRanges)
    ## computing coverage per each bin on chromosome
    if(verbose) message("Computing coverage on Chromosome ",
                        chrBedGRanges@seqnames@values,
                        " binned by ", binWidth, " bin dimension")
    chrCovRle <- binnedCovOnly(bins=binnedChromosome,
                               numvar=chrCoverage,
                               mcolname="bin_cov")

    wins <- minWinWidth:maxWinWidth
    runWinRleList <- IRanges::RleList(
                        lapply(wins, function(win) {
                            message("Running window ", win, " of ", maxWinWidth)
                            floor(evenRunMean(x=chrCovRle, k=win, endrule="constant"))
                        })
                     )
    return(runWinRleList)
}
 minCompRunWinRleList <- computeCoverageMovingWindowOnChr(
                                                    chrBedGRanges=chrGRanges,
                                                    minWinWidth=minCompWinWidth,
                                                    maxWinWidth=minCompWinWidth,
                                                    binWidth=binSize
                                                    )
            maxCompRunWinRleList <- computeCoverageMovingWindowOnChr(
                                                    chrBedGRanges=chrGRanges,
                                                    minWinWidth=maxCompWinWidth,
                                                    maxWinWidth=maxCompWinWidth,
                                                    binWidth=binSize
                                                    )
            ## test the lambdas with the old lambdas
            lambdaChrRleList <- computeLambdaOnChr(
                                       chrGRanges=chrGRanges,
                                       winVector=winVector,
                                       minChrRleWComp=minCompRunWinRleList[[1]],
                                       minCompWinWidth=minCompWinWidth,
                                       maxChrRleWComp=maxCompRunWinRleList[[1]],
                                       maxCompWinWidth=maxCompWinWidth
                                       )
            Zm <- computeZ(lambdaChrRleList=lambdaChrRleList,
                          runWinRleList=runWinRleList,
                          chrLength=chrGRanges@seqinfo@seqlengths,
                          minCount=minCount, binSize=binSize
                          )
             length(Z[which(Zm > 100, arr.ind=TRUE)])
```


```{r}
computeCoverageMovingWindowOnChr <- function(chrBedGRanges, minWinWidth=50,
                                             maxWinWidth=1000, binWidth=50,
                                             verbose=TRUE)
{
    ## converting base notation to bin notation
    minWinWidth <- minWinWidth/binWidth
    maxWinWidth <- maxWinWidth/binWidth

    ## dividing chromosome in bins of binWidth dimention each
    binnedChromosome <- GenomicRanges::tileGenome(seqlengths=chrBedGRanges@seqinfo,
                                                  tilewidth=binWidth,
                                                  cut.last.tile.in.chrom=TRUE)

    # olap <- GenomicAlignments::summarizeOverlaps(features=binnedChromosome,
    #                                              reads=chrBedGRanges,
    #                                              ignore.strand=TRUE,
    #                                              inter.feature=FALSE,
    #                                              mode="IntersectionNotEmpty")
    # #
    # # test the coverages with the old coverages using a small amount of reads
    # chrCovRle1 <- as(SummarizedExperiment::assays(olap)$counts, "Rle")

    ## computing coverage per single base on bed
    chrCoverage <- GenomicRanges::coverage(x=chrBedGRanges)
    ## computing coverage per each bin on chromosome
    if(verbose) message("Computing coverage on Chromosome ",
                        chrBedGRanges@seqnames@values,
                        " binned by ", binWidth, " bin dimension")
    chrCovRle <- binnedCovOnly(bins=binnedChromosome,
                               numvar=chrCoverage,
                               mcolname="bin_cov")

    wins <- minWinWidth:maxWinWidth
    runWinRleList <- IRanges::RleList(
                        lapply(wins, function(win) {
                            message("Running window ", win, " of ", maxWinWidth)
                            evenRunSum(x=chrCovRle, k=win, endrule="constant")
                        })
                     )
    return(runWinRleList)
}
 minCompRunWinRleList <- computeCoverageMovingWindowOnChr(
                                                    chrBedGRanges=chrGRanges,
                                                    minWinWidth=minCompWinWidth,
                                                    maxWinWidth=minCompWinWidth,
                                                    binWidth=binSize
                                                    )
            maxCompRunWinRleList <- computeCoverageMovingWindowOnChr(
                                                    chrBedGRanges=chrGRanges,
                                                    minWinWidth=maxCompWinWidth,
                                                    maxWinWidth=maxCompWinWidth,
                                                    binWidth=binSize
                                                    )
            ## test the lambdas with the old lambdas
            lambdaChrRleList <- computeLambdaOnChr(
                                       chrGRanges=chrGRanges,
                                       winVector=winVector,
                                       minChrRleWComp=minCompRunWinRleList[[1]],
                                       minCompWinWidth=minCompWinWidth,
                                       maxChrRleWComp=maxCompRunWinRleList[[1]],
                                       maxCompWinWidth=maxCompWinWidth
                                       )
            Zs <- computeZ(lambdaChrRleList=lambdaChrRleList,
                          runWinRleList=runWinRleList,
                          chrLength=chrGRanges@seqinfo@seqlengths,
                          minCount=minCount, binSize=binSize
                          )
            length(Zs[which(Zs > 100, arr.ind=TRUE)])
```







